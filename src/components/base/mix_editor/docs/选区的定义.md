# 选区的定义
编辑器由区域组成。

编辑器的光标系统需要确认选中区才能工作。但我们如何定义选中区?

## 光标后的就是选中区域？
如果我们把光标后的区域定义为选中区域，那这个是在`块区`前。这看起来没什么问题。
```
|<块区><文本区1:abc><文本区2:def></块区>
```

这个是选中了文本区2：
```
<块区><文本区1:abc>|<文本区2:def></块区>
```

当输入了文本，我们希望发生什么？是扩展`文本区1`，还是扩展`文本区2`？

按照我的个人直觉，我这是在为文本区1增加内容，所以我应该扩展文本区1。

但是如果沿用当前的策略，聚焦了文本区2却扩展了其上一个区域，这很奇怪吧？

## 光标前的就是选中区域？
如果我们把光标前的区域定义为选中区域，那这个是在`块区`后，但是选中了`块区`。这看起来没什么问题。
```
<块区><文本区1:abc><文本区2:def><文本区3:ghi></块区>|
```

这个是选中了文本区2，看起来也很合理，扩写的内容应该加进去：
```
<块区><文本区1:abc>|<文本区2:def></块区>
```

那我们如何处理文本区内的选区呢？我们应该这样做吗：
```
<块区><文本区1:abc|><文本区2:def></块区>
等价于
<块区><文本区1:abc>|<文本区2:def></块区>

且

<块区><文本区1:abc><文本区2:|def></块区>
等价于
<块区><文本区1:abc>|<文本区2:def></块区>
```

完美的方案！让我们试试一些边界情况。

## 那么，独立的文本区域呢？
如果我们有一些文本区是个性化的，希望与外界隔离的话：

```
<块区><独立文本区1:abc|><独立文本区2:def></块区>
→
<块区><独立文本区1:abc>|<独立文本区2:def></块区>
→
<块区><独立文本区1:abc><独立文本区2:|def></块区>
```

效果依然很不错，试试更多边界情况。

## 块区内的左边界
如果我们在块区内最右边，则聚焦当前的最后一个区域。如果是最左边。岂不是谁也没有聚焦？

```
<块区>
|<文本区1:abc>
</块区>
```

看来我们得更改我们的定义了，如果焦点处于区域x的内部的头部，则也算是聚焦于x。我们还得给这种聚焦区分类型，一个是光标在其后的聚焦，一个是光标在其内的聚焦。

## 区域里的虚拟区域
我们还注意到，文本区域的每个字都是没有被系统记录的区域，但是在实际上的选中区域的计算中也会参与。因此，选中区域还需要一个“虚拟子索引”来记录当前聚焦的部分。

例如：
```
<块区>
<文本区1:abc><文本区2:de|f>
</块区>
```

的选择区域记录是：
```json5
{
  选中区域上下文: 文本区2的上下文
  类型: 内部
  内部索引: [2]
}
```

## 结论
为了更符合用户使用的直觉，我们选择这样定义选中区域：
1. 光标前的区域为选中区域。
2. 光标前无区域，则选中父层区域，类型为内部，内部索引为[0]。
3. 选中区域类型分为光标尾随选中和光标内部选中。
