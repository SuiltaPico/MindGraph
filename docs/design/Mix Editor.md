# 概念
## 区域

区域是 MixEditor 中用于表示内容的基本单位，它定义了编辑器中可编辑内容的结构和类型。区域分为**块级区域 (Block Area)** 和 **行内区域 (Inline Area)** 两种主要类型，此外还有用于修饰行内区域的**行内标签 (Inline Tag)**。

### 块级区域 (Block Area)

块级区域用于表达一个独立的块级元素，通常在视觉上呈现为一个矩形，占据一行或多行空间。块级区域之间通常会有明显的视觉分隔，例如换行或垂直间距。

常见的块级区域类型包括：

* **段落 (Paragraph):**  最基本的块级区域，用于表示一段普通的文本内容，没有特殊的样式。
* **标题 (Heading):** 用于表示段落或内容的标题，通常字体更大、更醒目，用于组织和突出显示内容结构。
* **列表 (List):** 用于表示一组相关的项目，分为有序列表 (Ordered List) 和无序列表 (Unordered List) 两种。
* **引用 (Quote):** 用于表示一段引用自其他来源的文本内容，通常会有特殊的样式，例如缩进或引号。
* **代码块 (Code Block):** 用于表示一段代码，通常会使用等宽字体，并进行语法高亮显示。
* **多媒体 (Multimedia):** 用于嵌入图片、视频、音频等多媒体内容。
* **分割线 (Divider):** 用于在视觉上分隔不同的内容区域，通常是一条水平线。

### 行内区域 (Inline Area)

行内区域用于表达一个行内元素，它存在于块级区域内部，通常是允许跨行的，多个行内区域可以在同一行显示。

我们称没有下级子区域的行内区域为**末端行内区域**。例如文本区域。

常见的行内区域类型包括：

* **文本 (Text):** 最基本的行内区域，用于表示一段普通的文本内容。
* **图片 (Image):**  用于在文本中嵌入图片。

### 行内标签 (Inline Tag)

行内标签用于为行内区域添加修饰和语义信息，例如超链接、强调、删除线等。行内标签不会影响光标的移动，它们只影响文本的样式或功能。

常见的行内标签包括：

* **超链接 (Hyperlink):** 用于创建一个可点击的链接，指向其他网页或文档。
* **强调 (Emphasis):** 用于突出显示文本内容，通常使用斜体或粗体显示。
* **删除线 (Strikethrough):** 用于表示已删除或不再有效的文本内容。
* **代码段 (Code Span):** 用于表示一小段代码，通常使用等宽字体显示。
* **高亮 (Highlight):** 用于突出显示文本内容，通常使用背景色或不同颜色显示。

#### 接口
区域具有以下接口：
* `get_child(index: number)`：获取区域指定索引的子区域。
* `get_child_position(index: number)`：获取区域相对于编辑器的位置。

# 功能设计
## 选区
选区是 MixEditor 中用于表示用户当前选中的内容。选区包含起始位置和结束位置，其都是一个数组，记录了光标在区块中的位置。

选区提供了一系列的接口，用于获取选区信息、设置选区、移动选区等：
* `move_left()`：将选区向左移动一个位置。
* `move_right()`：将选区向右移动一个位置。

### 光标
光标是选区的可视化表示，它指示用户当前编辑的位置。光标的渲染位置、渲染方式、移动模式完全由插件提供的渲染器支持。MixEditor 只负责渲染器之间光标的协调调度，确保光标在不同渲染器之间能够正确地切换和显示。

#### 光标位置的计算
每次选区刷新时，MixEditor 会根据选区信息计算光标的位置。计算过程如下：
* 从根区域开始，按照选区位置数组中的索引，逐级调用 get_child 方法访问子区域。
* 当到达倒数第二个索引时，调用 get_child_position 方法，获取对应子区域相对于编辑器根节点的坐标位置。
* 根据最后一个索引，计算光标在子区域内的相对位置。


#### 光标的移动
光标移动时，会根据移动方向调用 `move_left` 或 `move_right` 方法，从而更新选区的位置。

`move_left` 和 `move_right` 方法被调用时，会根据移动方向，向对应方向的区域发起 `move_left_enter` 或 `move_right_enter` 事件。区域可以选择跳过到下一个区域，或者将事件传递给其子元素处理。直到事件被某个区域接收，或者到达最后一个区域时，编辑器会根据当前位置更新选区。

#### 末端行内区域的处理

针对末端行内区域，MixEditor 使用**无头有尾**的约定：

* 当 `move_left_enter` 事件到达行内区域的第一个子区域时，该区域应该跳过该子区域，并将事件继续向左传递，直到到达上一个区域的末尾。
* 当 `move_right_enter` 事件到达行内区域的最后一个子区域时，该区域应该跳过该子区域，并将事件继续向右传递，直到到达下一个区域的开头。

这种约定可以保证光标能够流畅地在行内区域之间移动，避免出现卡顿或跳跃的情况。